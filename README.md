readable_code
=============

# リーダブルなコード

## 抽象化・具体化レベルを揃える
* 既知から未知へ
  * Railsなら
      1. Controller#action
      2. Model#public_methods
      3. Model#private_methods
    とたどると
      1. 要求仕様
      2. 実装
      3. 実装詳細
    となっていくようにする
* エントリポイントに詳細なロジックを置かない
  * 前頭前野
    * まず「大きな脈略」を理解することが必要


## 推測しやすくする
* 比喩
  * 現実の知識を流用
  * 処理を正確に把握しなくても、メソッド名や変数名だけである程度デバッグできる
* 英語
* 規則を意識する

### 複数の情報を与える
* どこかに気づけばたどり着ける
  * ロバストな作り
* 他の経路と合わせることで検算できる
  * より深い安心感


## 規則を意識する
* 対義語
  * set / get
* パラレリズム
* 用語の統一
* 「読者の期待通りの場所に期待通りのことを書く」 (数学文章作法 P68)
  * 驚き最小の法則


## メソッド名は見出し
* コメントは最小限
  * できればないほうがいい
    * 当たり前のことは書かない
      * 重複したコード
      * 嘘コメントになる恐れ
      * 見ずらくなる
    * How でなく What を、手順ではなく目的を
      * WhatはHowに比べて変化しにくいので、リファクタリングしやすいメリットも
    * コードで語れ
  * なぜそれをしなかったのかは書く
    * きのこ17 コードに書けないことのみをコメントにする
  * コメントをメソッド名にできないか考える
* マジックナンバーを使わない
  * 定数などで名前をつける
* ななめ読み耐性 (「分かりやすい文章」の技術)
　* 文章強度 → 推測しやすい

### 名前重要


## 名前重要
* "send"、"tmp"、"data"
* "新しいフォルダ"
* "check"、"process"
  * 何にでも使える → 何に使っているか特定しにくい
  * 書きやすいが読みにくい
* スコープ、コンテキストを意識する
  * 広いスコープ → 長い名前
  * 狭いスコープ → 短い名前 (考慮すべきコンテキストが少ないので、説明は少なくていい)


## 整形
* レイアウト (「分かりやすい文章」の技術)
  * 見やすい文字配置
    * 改行 (1行1ステップ)
    * インデント
  * 情報構造がわかる
  * 「かたまり」を区別する
    * 「メソッドの抽出」へ
  * 見出しをつける

### 視覚的パターンマッチング
* きのこ13 コードレイアウトの重要性 - プログラマが知るべき97のこと


## 明解に
* 二重否定は避ける
  * ドモルガンの法則を使って簡単に
* ネスト
  * ネスト ＝ スタック
    * 深さ ＝ つらさ
  * 例外処理はガード節に
* 分ける
  * 「分ける」→「分かる」
    * マジカルナンバー７(±2)
      * 5以下ならひと目で把握できる
    * チャンク化
  * 一時変数を減らす
    * マジカルナンバー７
    * スコープを狭くできる → 短い名前
    * メソッドにしてしまう
* シンプルに
  * 将来こういう使い方をするかもという先行投資はしない
    * クラス/メソッド/モジュール/インターフェース
      * 部品、結合部分が減る → 複雑度が下がる
    * 必要になったときに実装する
      * 自動テストによるデグレ防止
  * 余分なコードは書かない


## DRY
* コピペしない
　* データ(一時変数含む)も複製しない
    * 速度を稼ぎたい場合は、必ずベンチマークを行う


## 郷に入っては郷に従え
* コミュニティでの慣習的な表現
  * 複数の優秀な人によって、長期間、様々なコンテキストで検討され、磨かれ、選択されてきた「エキス」
    * ベストプラクティス
      * 試行錯誤が減る
      * もっといいやり方があるのではないか、と悩むことが減る
* 言語の標準ライブラリ、フレームワーク、定番の外部ライブラリを知る
  * 詳しい人にレビューしてもらう
  * 公開されているソースコードを読む
  * 独自ライブラリ、独自フレームワークは本当に必要か?
    * 開発をコントロールできる
    * Google、Stack Overflowが使えない
    * 品質保証は?


## 抽象度を上げ過ぎない
* 抽象度を上げると共通化しやすい
  * 具体度が下がる
  * エントリポイント - エンドポイントの距離が離れる → 部品が増える ＝ 複雑
  * 抽象的なことは理解しにくい
    * 人類には早すぎるコード
    * 難易度が高い
      * 手を入れられる人、レビュワーが限られる
      * 要員の確保によるスケールが困難
* 上げる場合は使用法、例を併記


## 嫌な臭い
* パッと見て意味がとれない
  * 可読性に難あり、バグが入り込む隙になる
  * マジカルナンバー７
* 処理内容が第一印象に反する
  * 「実装」から「正しい解釈」を導き出し、コードリーディング中ずっと保持し続けなければならない
    * 正しい名前、定石を


## 自然言語力を鍛えよう！
* センス大事
  * 語彙
    * 複数の候補
    * 表現の解像度を上げる → スコープを狭める
* 英語
  * コードに効く英語 ～正しく読めて“伝わる”クラス／メソッド名～ (WEB+DB PRESS Vol.74)


## 意図を込める
* if文 : 優先順位があるもの
  * unless文 : 正で*あって欲しい*がそうでない場合
* case文 : 優先順位がないもの

※Rubyの場合


## コードは誰のもの
* コンピュータ？
  * 論理的に正しければ正しく動く
* 書いた人？
  * 過去の自分は他人

### 初めてそのコードを読む人のためのもの
* コードはインターフェース
  * Write your own DSL
  * 変更を加えるべき箇所の特定、影響範囲の調査 → 読む時間のほうが長い
    * 後で楽に読めるよう、書く時に苦労しておく


## 参考文献

* プログラミング作法
* リーダブルコード
* 記憶力を強くする
* 「分かりやすい文章」の技術
* 相手に「伝わる」話し方
* 数学文章作法 基礎編
* リファクタリング:Rubyエディション
* プログラマが知るべき97のこと
