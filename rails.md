Ruby on Rails
=============

## リファクタリング

小さく書かれたコードがそのままの構造でだんだん大きくなることが多い。
小さなコードと大きなコードでは好ましいあり方が異なり、大きなコードではロジックを複数のメソッドやクラスに分割するほうが管理しやすい。
このため、大きなコードを分割することが作業の中心になる。

1. テストを書き、ふるまいを固定する
2. 必要に応じて以下を行う
  * 一時変数をメソッドにする
    + 一時変数への代入は大抵処理の単位となるので、そのままメソッド化する
  * `each` を `map` で書き直す
  * 複雑な処理を委譲で別クラスに抽出する
    + 単体テストも分離する
      - 考慮すべき値の組み合わせを抑えやすいので、管理しやすくなりカバレッジも上げやすい

### コード分割

#### 利点

* コードの再利用がしやすい
  + コードを改修する際に、十分テストされたメソッドやクラスの組み合わせを変えるだけですむことが多くなる。改修によるデグレのリスクが抑えられる
* テストしやすい
  + 責務が限られていると考慮すべき事前条件も少なくできる。反対に責務や処理の単位が大きいとテストコードの見通しが悪くなる。カバレッジが下がりがち
    * セットアップが長くなる
    * パターンの組み合わせが多くなりネストが深くなる
    * 準備（Arrange）と実行（Act）・確認（Assert）の間の視線移動が煩雑
* 処理の途中のデータを確認しやすい
  + 複数の処理を含んだ長大なメソッドは、その途中でデータがどうなっているかを確認するのに Break point を置くか print デバッグをすることになり効率が落ちる
  + メソッドであれば必要に応じて戻り値を確認できるので効率がいい
  + デバッガやコード修正を必要としないので、QA 環境などで不具合調査が容易（`rails console` が使える場合）
* Git でコンフリクトの解消がしやすい（このメリットを活かすには、コミットを大きくしないことも必要）
  + コンフリクトがあっても小さめになる
  + どのような変更をするのかがわかりやすいので判断が容易

#### 欠点

* メソッド定義など処理の本質でないコードの割合が増える
* 視線移動が増え、処理全体を把握しにくくなる
* コールスタックが深くなると、コードを読む人への負担になる

分割も過剰だとデメリットがメリットを上回ることもある。
保守性を下げない範囲で、コードをインライン化するような判断も必要。

## Model

* 複雑な SQL を構築せず、SQL ではロードのみ行いロジックは Ruby で書く
  + SQL のテストをするということは DB にアクセスするということなので、テストが遅くなりがち
  + SQL は分割しにくいが、Ruby のコードなら分割しやすい。デバッグもしやすい
  + とはいえ多くのレコードやテーブルにアクセスし、Rails レイヤーで行うとパフォーマンスの問題が発生する処理もあるので、絶対ではない
* データはなるべく生成されたときの状態を保ったまま保存する
  + 変換で失われた情報が後に必要になることはよくある
  + 変換処理自体に不具合がある場合、原因の特定の難易度が上がる
  + データの変換は、その必要が生じるまでなるべく行わない
* `has_one through` や `has_many through` の過度な使用は避ける
  + オブジェクトのメソッドチェインを縮めるために使うと、デメテルの法則に反し離れたモデル同士の結合を強めてしまう
  + 中間テーブルに使うのはもちろん OK
* 名前空間を使う
  * 関連するコードは名前空間を使って近くに配置する
    * 「脳に収まるコードの書き方」 P34 "関連するコードは近いところに置きましょう"
* ロジックの深い部分で直接環境変数を参照することは避ける
  * ロジックの入り口で環境変数の値を渡すようにする

### テーブル

* `has_one` を使い、テーブルを意味単位で分割する
  + 不要なカラムへのアクセスを最小限にできる
  + 対応する `ActiveRecord::Base` を継承するモデルの責務を分けられる
* 名前空間を使う
  + `has_one` で分割をするとテーブル数が多くなるので、名前空間を使う
    - e.g. `User`, `User::Profile`, `User::Address`
    - model をグループ化でき管理しやすくなる
    - 名前の衝突が起きにくくなる
* `UPDATE` より `INSERT`
  + UPDATE では行ロックなど、同一レコードの更新処理に対し何らかのケアが必要になる。またレコードが頻繁に更新される場合、行ロックがパフォーマンス上のネックになる恐れがある
  + UPDATE では保存される事実に対しかなり限られた情報しか保存されない
* 自動テストにおいて、マスターテーブルのレコードは都度作成する
  + すべてのテストで実行される共通処理で、一律に作成しない
    - テストの実行時間が長くなる

### FactoryBot

`FactoryBot.build` したもので単体テストをしやすい状態を基本とする。
このとき特定の単体テスト向けの設定を入れると factory が不要なコンテキストと密結合してしまう。
複数の factory を同時に利用したいときに、コンテキスト同士の衝突の解消に多大なエネルギーを必要とするようになる。

* `association` は指定しない
  + とはいえ外部キー制約で作成せざるを得ないことも多いので、`trait` で関連も作れるようにする
* callback で他モデルを生成したい場合もオプション（`trait`）にし、必要なところでだけ使う

## コントローラ

* JSON は View 的に扱われるが、していることはデータの共有。フロントエンドやアプリの View 構造に合わせすぎない。

## テスト

テストにかかる時間を短くする。
DB アクセスを減らすことが重要で、そのために**不要なレコード生成を極力避ける**。

### Controller

インテグレーションテストよりモデルのテストに寄せる

* インテグレーションテストは以下の点でモデルのテストよりかなり時間がかかる
  1. テストしたいビジネスロジック以外に必要とされる処理が多い
  2. **DB アクセスを避けることが難しい**
     テストの際、DB にレコードを作る必要がある
* コントローラに複雑なロジックがある場合はその部分をモデルとして抽出し、モデルとしてテストする

### Model

なるべく DB へのアクセスを減らす。
DB アクセスが多いとテストに時間がかかるようになり、

* 開発速度が下がり開発体験が悪化する。
* 自動テストがすべてOKになることを確認してからリリースされるような CI が構築されている場合、リリースの速度にも影響がある。
* 不具合が発生したときの修正やロールバックにも影響する

などのデメリットが顕著になる。

* `Model.new` で済むところで `Model.create` しない
  - `model.associations.build` や `model.build_association` を使う。`model.associations.create` や `model.create_association` は避ける
  - FactoryBot であれば、`FactoryBot.create` ではなく `FactoryBot.build` を利用する
* callback でレコード生成をしない
  + テスト時に不要なレコードが生成され、テストが遅くなる
  + 所々で callback を無効化する処理が必要となる
  + 専用のメソッドやサービスクラスなどで作成するようにする
* ロジックの責務を複数のモデルに分け、テストに必要な組み合わせ数を減らす
  + 末端のモデルで境界値を厳密にテストし、そのモデルの呼び出し側では代表値を使う


