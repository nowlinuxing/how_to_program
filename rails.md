Ruby on Rails
=============

## リファクタリング

小さく書かれたコードがそのままの構造でだんだん大きくなることが多い。
小さなコードと大きなコードでは好ましいあり方が異なり、大きなコードではロジックを複数のメソッドやクラスに分割するほうが管理しやすい。
このため、大きなコードを分割することが作業の中心になる。

1. テストを書き、ふるまいを固定する
2. 必要に応じて以下を行う
  * 一時変数をメソッドにする
    + 一時変数への代入は大抵処理の単位となるので、そのままメソッド化する
    + 一時変数は Break point を置くか print デバッグなどをしないと参照できないが、メソッドであれば必要に応じて呼び戻り値を確認できるのでデバッグ効率がいい
  * `each` を `map` で書き直す
  * 複雑な処理を移譲で別クラスに抽出する
    + 単体テストも分離する
      - 考慮すべき値の組み合わせを制限できるので、管理しやすくなりカバレッジも上げやすい

責務や処理の単位が大きいと、テストコードの見通しが悪くなりカバレッジが下がりがちになる。必要に応じて分割時にテストを追加する。

## Model

* データはなるべく生成されたときの状態を保ったまま保存する
* callback でレコード生成をしない
  + テスト時に不要なレコードが生成され、テストが遅くなる
  + 専用のメソッドやサービスクラスなどで作成するようにする
* 複雑な SQL を構築せず、SQL ではロードのみ行いロジックは Ruby で書く
  + SQL のテストをするということは DB にアクセスするということなので、テストが遅くなりがち
  + SQL は分割しにくいが、Ruby のコードなら分割しやすい。デバッグもしやすい
  + DB にレコードを作成しない単体テストを書けるので、テスト実行時間を短く保てる
  + とはいえ多くのレコードやテーブルにアクセスし、Rails レイヤーで行うとパフォーマンスの問題が発生する処理もあるので、絶対ではない

なるべく DB へのアクセスを減らす。
DB アクセスが多いとテストに時間がかかるようになり、開発速度が下がり開発体験が悪化する。

自動テストがすべてOKになることを確認してからリリースされるような CI が構築されている場合、リリースの速度にも影響がある。
不具合が発生したときの修正やロールバックにも影響する。
テストの遅さには注意が必要。

### テーブル

* `has_one` を使い、テーブルを意味単位で分割する
  * 不要なカラムへのアクセスを最小限にできる
  * 対応する `ActiveRecord::Base` を継承するモデルの責務を分けられる
* 名前空間を使う
  + e.g. `User`, `User::Profile`, `User::Address`
  + `has_one` で分割をするとテーブル数が多くなるので、名前空間を使う
    - model をグループ化でき管理しやすくなる
    - 名前の衝突が起きにくくなる
* `UPDATE` より `INSERT`
* マスターテーブルのようなものも、都度作成する
  + すべてのテストで実行される共通処理で、一律に作成しない
    - テストの実行時間が長くなる

### FactoryBot

`FactoryBot.build` したもので単体テストをしやすい状態を基本とする。

* `association` は指定しない
  + とはいえ外部キー制約で作成せざるを得ないことも多いので、`trait` で関連も作れるようにする
* callback で他モデルを生成したい場合はオプション（`trait`）にし、必要なところでだけ使う

## コントローラ

* JSON は View 的に扱われるが、していることはデータの共有。フロントエンドやアプリの View 構造に合わせすぎない。
